# SICP-reading-notes

# 1 构造过程抽象
## 1.1 程序设计的基本元素

每种语言都提供了三种机制

* **基本表达形式** 用于表示语言所关心的最简单的个体
* **组合的方法** 通过它们可以从较简单的东西出发构造出复合的元素
* **抽象的方法** 通过它们可以对复合对象命名，并将它们当做单元去操作

程序设计中需要处理的两类要素：**过程和数据**（实际上并不是这样严格去分离的）

### 1.1.1 表达式
形式：**前缀表示**

表里最左的元素称为**运算符**，其他元素称为**运算对象**。

例如：

`（+ 137 349）`  
`486`

这样的表达式称为**组合式**

**美观打印**格式规则：其中的各个运算对象垂直对齐

### 1.1.2 命名和环境
给事物命名通过`define`的方式完成  

`(define <name> value or operation)`  
`(define pi 3.14159)`  
`(define radius 10)`  
`(define circumference (* 2 pi radius))`

我们可以将值与符号关联，意味着解释器必须维护某种储存能力，一边保持有关的名字-值对偶过程。这种储存被称为**环境**（更精确地说，是**全局环境**）

### 1.1.3 组合式的求值
* 要求值一个组合式，要做下面的事情
* 1） 求值该组合式的各个子表达式
* 2） 将作为最左子表达式（运算符）的值的那个过程运用于相应的实际参数，所谓实际参数也就是其他子表达式（运算对象）的值。

在性质上，这一求值过程是**递归**的，也就是说，它在自己的工作步骤中，包含着调用这个规则本身的需要。

* 环境所扮演的角色就是用于确定表达式中各个符号的意义

### 1.1.4 复合过程
**过程定义：**可以为复合操作提供名字，而后可以将这样的操作作为一个单元使用(过程体也可以是一系列的表达式)  

`(define (<name> <formal parameters>) <body>)`  
`(define (square x) (* x x))`

### 1.1.5 过程应用的代换模型
* 代换的作用只是帮助我们领会过程调用中的情况，实际中，解释器一般采用提供形式参数的局部环境的方式，产生“代换的效果”

**应用序与正则序**  
* **正则序求值：** “完全展开而后归约”的求值模型  
* **应用序求值：** “先求值参数而后应用”的方式  
* Lisp采用应用序求值

### 1.1.6 条件表达式和谓词
在Lisp里有针对分情况分析的特殊形式，称为`cond`，使用形式如下

`(cond (<p1> <e1>)`  
　　　`(<p2> <e2>)`  
　　　`...`  
　　　`(<pn> <en>))`

第一个表达式是一个**谓词**，也就是说，它的值被解释成真或者假（在Scheme里用常量`#t`和`#f`表示）
